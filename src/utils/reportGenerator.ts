// src/utils/reportGenerator.ts
import * as fs from 'fs';
import * as path from 'path';

/**
 * Report Generator for creating self-contained HTML test health reports.
 *
 * This utility reads test results JSON files and embeds them directly
 * into the HTML report, creating a self-contained file that can be opened
 * directly in a browser without needing a server.
 */
export class ReportGenerator {
    private readonly outputDir: string;
    private readonly reportFileName: string;

    /**
     * Creates a new ReportGenerator instance
     * @param outputDir - Directory where the report will be generated
     * @param reportFileName - Name of the generated report file (default: 'test-health-report.html')
     */
    constructor(outputDir: string, reportFileName: string = 'test-health-report.html') {
        this.outputDir = outputDir;
        this.reportFileName = reportFileName;
    }

    /**
     * Generates a self-contained HTML report from test results
     * @returns The absolute path to the generated report file
     */
    public generateReport(): string {
        console.log('\nğŸ“Š Generating self-contained test health report...');

        // Get paths to template files (bundled with the package)
        // Templates are copied to dist/templates during build
        const templateDir = path.resolve(__dirname, '..', 'templates');
        const htmlTemplatePath = path.join(templateDir, 'test-health-report.html');
        const cssPath = path.join(templateDir, 'test-health-report.css');
        const jsPath = path.join(templateDir, 'test-health-report.js');

        // Verify template directory exists
        if (!fs.existsSync(templateDir)) {
            console.error(`  âœ— Template directory not found: ${templateDir}`);
            console.error('  Make sure the package was built correctly with: npm run build');
            throw new Error(`Template directory not found: ${templateDir}`);
        }

        // Paths to test data files
        const summaryPath = path.join(this.outputDir, 'testSummary.json');
        const failuresPath = path.join(this.outputDir, 'testFailures.json');

        // Read test data
        let testSummary = null;
        let testFailures = null;

        if (fs.existsSync(summaryPath)) {
            try {
                testSummary = JSON.parse(fs.readFileSync(summaryPath, 'utf-8'));
                const testCount = testSummary?.allTestCases?.length || testSummary?.testCount || 0;
                console.log(`  âœ“ Loaded testSummary.json (${testCount} tests)`);
            } catch (error) {
                console.warn(`  âš  Failed to parse testSummary.json: ${error}`);
            }
        } else {
            console.warn('  âš  testSummary.json not found, report will use sample data');
        }

        if (fs.existsSync(failuresPath)) {
            try {
                testFailures = JSON.parse(fs.readFileSync(failuresPath, 'utf-8'));
                const failureCount = Array.isArray(testFailures)
                    ? testFailures.length
                    : testFailures?.failures?.length || 0;
                console.log(`  âœ“ Loaded testFailures.json (${failureCount} failures)`);
            } catch (error) {
                console.warn(`  âš  Failed to parse testFailures.json: ${error}`);
            }
        } else {
            console.warn('  âš  testFailures.json not found, report will use sample data');
        }

        // Read HTML template
        if (!fs.existsSync(htmlTemplatePath)) {
            console.error(`  âœ— HTML template not found: ${htmlTemplatePath}`);
            throw new Error(`HTML template not found: ${htmlTemplatePath}`);
        }
        let html = fs.readFileSync(htmlTemplatePath, 'utf-8');
        console.log('  âœ“ Loaded HTML template');

        // Read CSS
        let css = '';
        if (fs.existsSync(cssPath)) {
            css = fs.readFileSync(cssPath, 'utf-8');
            console.log('  âœ“ Loaded CSS');
        } else {
            console.warn('  âš  CSS file not found');
        }

        // Read JS
        let js = '';
        if (fs.existsSync(jsPath)) {
            js = fs.readFileSync(jsPath, 'utf-8');
            console.log('  âœ“ Loaded JavaScript');
        } else {
            console.warn('  âš  JavaScript file not found');
        }

        // Create embedded data script
        const embeddedDataScript = `
<script>
// Embedded test data - generated by PlaywrightTestReporter
window.EMBEDDED_TEST_SUMMARY = ${testSummary ? JSON.stringify(testSummary, null, 2) : 'null'};
window.EMBEDDED_TEST_FAILURES = ${testFailures ? JSON.stringify(testFailures, null, 2) : 'null'};
</script>`;

        // Create inline CSS
        const inlineCSS = css
            ? `
<style>
${css}
</style>`
            : '';

        // Create inline JS
        const inlineJS = js
            ? `
<script>
${js}
</script>`
            : '';

        // Replace external CSS link with inline CSS
        html = html.replace(/<link[^>]*href=["']test-health-report\.css["'][^>]*>/gi, inlineCSS);

        // Replace external JS script with inline JS (add embedded data before it)
        html = html.replace(
            /<script[^>]*src=["']test-health-report\.js["'][^>]*><\/script>/gi,
            embeddedDataScript + inlineJS
        );

        // If the replacements didn't work, insert before </head> and </body>
        if (!html.includes('EMBEDDED_TEST_SUMMARY')) {
            html = html.replace('</head>', `${inlineCSS}\n${embeddedDataScript}\n</head>`);
            html = html.replace('</body>', `${inlineJS}\n</body>`);
        }

        // Add generation timestamp
        const timestamp = new Date().toISOString();
        html = html.replace('</head>', `<meta name="generated" content="${timestamp}">\n</head>`);

        // Ensure output directory exists
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, {recursive: true});
        }

        // Write output file
        const outputPath = path.join(this.outputDir, this.reportFileName);
        fs.writeFileSync(outputPath, html, 'utf-8');

        const absoluteOutputPath = path.resolve(outputPath);
        console.log(`  âœ“ Generated standalone report: ${absoluteOutputPath}`);

        return absoluteOutputPath;
    }

    /**
     * Prints the report link to console
     * @param reportPath - The path to the generated report
     */
    public static printReportLink(reportPath: string): void {
        const fileUrl = `file:///${reportPath.replace(/\\/g, '/')}`;
        
        console.log('\n');
        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘                    ğŸ“Š Test Health Report                     â•‘');
        console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
        console.log(`â•‘  Open in browser: ${fileUrl}`);
        console.log('â•‘                                                              â•‘');
        console.log('â•‘  Or run: npx playwright show-report (if using Playwright)   â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('\n');
    }
}
